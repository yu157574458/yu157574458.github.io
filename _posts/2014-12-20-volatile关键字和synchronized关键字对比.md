---
layout: post
title: "volatile和synchronized的学习"
description: "volatile和synchronized的学习"
categories: [java基础]
tags: [volatile,synchronized]
redirect_from:
  - /2014/12/20/
---
> 简介：多线程里经常出现volatile和synchronized两关键字的问题，volatile相比锁，volatile变量是一种非常简单但同时非常脆弱的的同步机制。volatile轻量级，只能修饰变量。synchronized重量级，还可修饰方法。volatile只能保证变量内存可见性，不能保证原子性。

## 一、volatile关键字的可见性
要想理解volatile关键字，得先了解下JAVA的内存模型，Java内存模型的抽象示意图如下：


![volatile](..\..\..\..\..\assets\images\logimages\20141220\volatile.png)

从图中可以看出：

①每个线程都有一个自己的本地内存空间--线程栈空间。当线程执行时，先把变量从主内存读取到线程自己的本地内存空间，然后再对该变量进行操作

②对该变量操作完后，在某个时间再把变量刷新回主内存

volatile 关键字修饰的作用是强制线程从主内存中取 volatile修饰的变量。   
当多个线程之间需要根据某个条件确定 哪个线程可以执行时，要确保这个条件在 线程 之间是可见的。因此，可以用volatile修饰。

**综上，volatile关键字的作用是：使变量在多个线程间可见（可见性）**

## 二、volatile关键字的非原子性

所谓原子性，就是某系列的操作步骤要么全部执行，要么都不执行。

比如，变量的自增操作 i++，分三个步骤：

①从内存中读取出变量 i 的值

②将 i 的值加1

③将 加1 后的值写回内存

这说明 i++ 并不是一个原子操作。因为，它分成了三步，有可能当某个线程执行到了第②时被中断了，那么就意味着只执行了其中的两个步骤，没有全部执行。

比如，假设 i 自增到 5，线程A从主内存中读取i，值为5，将它存储到自己的线程空间中，执行加1操作，值为6。此时，CPU切换到线程B执行，从主从内存中读取变量i的值。由于线程A还没有来得及将加1后的结果写回到主内存，线程B就已经从主内存中读取了i，因此，线程B读到的变量 i 值还是5

相当于线程B读取的是已经过时的数据(虽然也是主内存的数据)了，从而导致线程不安全性。  
**综上，仅靠volatile不能保证线程的安全性。（原子性）**

## 三、volatile 与 synchronized 的比较

volatile主要用在多个线程感知实例变量被更改了场合，从而使得各个线程获得最新的值。它强制线程每次从主内存中讲到变量，而不是从线程的私有内存中读取变量，从而保证了数据的可见性。

①volatile轻量级，只能修饰变量。synchronized重量级，还可修饰方法

②volatile只能保证数据的可见性，不能用来同步，因为多个线程并发访问volatile修饰的变量不会阻塞。

synchronized不仅保证可见性，而且还保证原子性，因为，只有获得了锁的线程才能进入临界区，从而保证临界区中的所有语句都全部执行。多个线程争抢synchronized锁对象时，会出现阻塞。

## 四、线程安全性

线程安全性包括两个方面，①可见性。②原子性。

从上面自增的例子中可以看出：仅仅使用volatile并不能保证线程安全性。而synchronized则可实现线程的安全性。